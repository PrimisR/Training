#### Josephus Problem

##### 递推(Recurrence)

```c
#include <stdio.h>
#define STEP 5000000

int m;
int x;
int result[200]={1,3041345,3093025,4639537,19639537,14459305,29459305,14188957,29188957,44188957,13783435,28783435,43783435,58783435,5675152,67295095,35675152,18442642,33442642,48442642,63442642,78442642,93442642,108442642,5163962,20163962,35163962,50163962,65163962,80163962,95163962,110163962,125163962,140163962,155163962,170163962,7745942,22745942,37745942,52745942,67745942,82745942,97745942,112745942,127745942,142745942,157745942,172745942,187745942,202745942,217745942,232745942,247745942,262745942,11618912,26618912,41618912,56618912,71618912,86618912,101618912,116618912,131618912,146618912,161618912,176618912,191618912,206618912,221618912,236618912,251618912,266618912,281618912,296618912,311618912,326618912,341618912,356618912,371618912,386618912,2428367,180605450,32428367,210605450,62428367,240605450,92428367,270605450,122428367,300605450,152428367,330605450,182428367,360605450,212428367,390605450,242428367,420605450,272428367,450605450,302428367,480605450,332428367,510605450,362428367,23408174,392428367,53408174,422428367,83408174,452428367,113408174,482428367,143408174,512428367,173408174,542428367,203408174,572428367,233408174,3642550,18642550,33642550,48642550,63642550,78642550,93642550,108642550,123642550,138642550,153642550,168642550,183642550,198642550,213642550,228642550,243642550,258642550,273642550,288642550,303642550,318642550,333642550,348642550,363642550,378642550,393642550,408642550,423642550,438642550,453642550,468642550,483642550,498642550,513642550,528642550,543642550,558642550,573642550,588642550,603642550,618642550,633642550,648642550,663642550,678642550,693642550,708642550,723642550,738642550,753642550,768642550,783642550,798642550,813642550,828642550,843642550,858642550,873642550,888642550,5463824,20463824,35463824,50463824,65463824,80463824,95463824,110463824,125463824,140463824,155463824,170463824,185463824,200463824,215463824,230463824,245463824,260463824,275463824,290463824};//尝试打表，失败
int main()
{
	while(~scanf("%d",&m))
{	
	for(int s=0;s<=200;s++)
	{
		if(m<(s+1)*STEP)
		{
			x=result[s];
			for(int i=s*STEP;i<m;i++)
				x=(x+3)%(i+1);//递推关系式
			printf("%d\n",x+1);
			break;
		}
	}
}
}
```

每杀死一个人，就在后面重新标号，这个新形成的环留下的人就是前一个问题的解，找出前后问题解的对应关系式，形成递推。

但本题目数据量过大（1e9），故会超时，打表200个数依然失败超时。（200个打表耗时10分钟左右）

时间复杂度O(n)。

在k(杀死的人数)较小，而n较大的时候，可以采用新的递推方式，先杀死一轮人（k,2k,...,[n/k]）的递推公式，时间复杂度为：
$$
O(k\space log\space n )
$$
递推公式为：
$$
f(n,k)=\begin{cases}
0 & if\space n=1 \\
(f(f(n-1)+k)\space mod\space n &if\space 1<n\\
[\frac{k((f(n',k)-n\space mod\space k)\space mod \space n')}{k-1}]\space where \space n'=n-[\frac{n}{k}] &if\space k\le n
\end{cases}
$$

（Wiki）程序实现（C++）：

```c
#include <cstdio>
using namespace std;
//編號從1開始，結果要加1
int josephus(int n, int k) { 
    if (k==1) return n-1;
    int ans=0;
    for (int i=2;i<=n;)
    {
	if (ans+k>=i)
	{
	     ans=(ans+k)%i;
	     i++;
	     continue;
	}
	int Step=(i-1-ans-1)/(k-1);//向下取整
	if (i+x>n) 
	{
	    ans+=(n-(i-1))*k;break;
	}
	i+=Step;ans+=Step*k;
    }
    return ans;
}

int main() {
	while (~scanf("%d%d",&n,&k)
            printf("%d\n",josephus(n,k)%n+1);
	return 0;
}
```

公式递推：

```c
#include <stdio.h>

#define K 3

int m;

int j(int x)
{
	if(x==1) return 0;
	if(x>1&&x<K) return (j(x-1)+K)%x;
	if(x>=K) return K*((j(x-x/K)-(x%K)+(x-x/K))%(x-x/K))/(K-1);//由于计算机取模是负的，加上一个模数
}

int main()
{
	while(~scanf("%d",&m))
{
	printf("%d\n",j(m)+1);
}
}
```

完全公式照搬。

##### OJ上的AC码：

##### 观察规律（不知道是不是真的能观察出来）：

```c
#include<stdio.h>
int main()
{
    int m;
    while(scanf("%d",&m)!=EOF)
    {
        int num=0;
        for(int i=2;i<=m;i++)//+1用来从一组结尾到下一组开头
        {
            num+=3;num%=i;//开头位置
           if(num+3<i)
            {
               int t=(i-num)/2;//为什么/2是正确结果？这个2是3-1吗？有没有什么联系？
                if((num+3*t)==(i+t)) t--;//组别分类，计算组距
                num+=3*t;//结尾位置
                i+=t;//跳过这一组
                if(i>m) num-=3*(i-m);//如果超过了，返回来
            }
        }
        printf("%d\n",num+1);
    }
    return 0;
}


```

使用这个方法，首先写打表：

| 组别 | i    | num((num+3)%i) | 组别分类 | 组距t+1 |
| ---- | ---- | -------------- | -------- | ------- |
| 1    | 1    | 0              |          |         |
| 2    | 2    | 1              |          |         |
| 3    | 3    | 1              |          |         |
| 4    | 4    | 0              | t--      | 2       |
|      | 5    | 3              |          |         |
| 5    | 6    | 0              | 不变     | 3       |
|      | 7    | 3              |          |         |
|      | 8    | 6              |          |         |
| 6    | 9    | 0              |          |         |
|      | 10   | 3              |          |         |
|      | 11   | 6              |          |         |
|      | 12   | 9              |          |         |
|      | 13   | 12             |          |         |
| 7    | 14   | 1              |          |         |
|      | 15   | 4              |          |         |
|      | 16   | 7              |          |         |
|      | 17   | 10             |          |         |
|      | 18   | 13             |          |         |
|      | 19   | 16             |          |         |
|      | 20   | 19             |          |         |
| 8    | 21   | 1              |          |         |
|      | 22   | 4              |          |         |
|      | 23   | 7              |          |         |
|      | 24   | 10             |          |         |
|      | 25   | 13             |          |         |
|      | 26   | 16             |          |         |
|      | 27   | 19             |          |         |
|      | 28   | 22             |          |         |
|      | 29   | 25             |          |         |
|      | 30   | 28             |          |         |
| 9    | 31   | 0              |          |         |
|      | 32   | 3              |          |         |
|      | 33   | 6              |          |         |
|      | 34   | 9              |          |         |
|      | 35   | 12             |          |         |
|      | 36   | 15             |          |         |
|      | 37   | 18             |          |         |
|      | 38   | 21             |          |         |
|      | 39   | 24             |          |         |
|      | 40   | 27             |          |         |
|      | 41   | 30             |          |         |
|      | 42   | 33             |          |         |
|      | 43   | 36             |          |         |
|      | 44   | 39             |          |         |
|      | 45   | 42             |          |         |
|      | 46   | 45             |          |         |
| 10   | 47   | 1              |          |         |
|      | 48   | 4              |          |         |
|      | ...  |                |          |         |

然后反复进行操作，用i与m关系判断区间，这样可以不断跳过区间，加快速度。

##### 坐标递推：


```c
#include <stdio.h>
int f(int n)
{
    if(n==1)return 0;
    if(n==2)return 1;
    int k = f(n - n/3);
    int t = n % 3;
    if( k < t )//分类讨论
        return n - t + k;
    return (k-t) / 2 * 3 + (k - t) % 2;//递归写递推式子，像写公式一样写。
}
 
int main()
{
    int n;
    while(scanf("%d",&n)!=EOF)
        printf("%d\n",f(n)+1);
    return 0;
}
```
坐标递推的分类讨论，如果前一个问题的解在新问题最后死人的后面，进行相应变换；在最后死人前面，进行两个两个（k-1个）分组坐标变换。

| 1    | 2    | X    | 3    | 4    | X    | 5    | 6    | X（LAST） | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | --------- | ---- |
| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8         | 9    |

注意：一般从0开始标起，便于求模，有时便于寻找规律。

```c
#include <stdio.h>

long josephus(long n,long m,long k)
{
    if (m == 1)k = k == 1 ? n : (k + n - 1) % n;
    else
    {
        for (long i = 1; i <= n; i++)
        {
            if ((k + m) < i)
            {
                long x = (i - k + 1) / (m - 1) - 1;
                if (i + x < n)
                {
                    i = i + x;
                    k = (k + m * x);
                }
                else
                {
                    k = k + m * (n - i) ;
                    i = n;
                }
            }
            k = (k + m - 1) % i + 1;
        }
    }
    return k;
}
int main()
{
    long m;
    while(scanf("%ld",&m)!=EOF)
    {
        printf("%ld\n",josephus(m,3,1));
    }
    return 0;
}
```

通用的约瑟夫斯函数。（进一步思考其解释）